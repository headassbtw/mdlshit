#pragma once
#include <cstddef>
#include <string>
#include <optional>
#include <vector>
#include <utility>

using std::byte;
using std::string;

#define MAX_NUM_LODS 8
#define MAX_NUM_BONES_PER_VERT 3
#define DEBUG false

struct FileInfo {
	std::optional<std::string> mdl; //main mdl file
	std::optional<std::string> vtx; //vertices
	std::optional<std::string> vvd; //vertex data
	std::optional<std::string> vvc; //i'm gonna skin rika alive for thinking we need this shit
	std::optional<std::string> phy; //physics data
	std::optional<std::string> pfb; //extra physics stuff
	std::optional<std::string> str; //extra structs
	std::optional<std::string> aabb; //aabb tree
	std::optional<std::string> rui; //rui shit
	std::optional<std::string> out; //output file
};

struct sizes
{
	int v49_Bone = 216;
	int v53_Bone = 244;
	int v49_AnimDesc = 100;
	int v53_AnimDesc = 92;
	int v49_SeqDesc = 212;
	int v53_SeqDesc = 232;
	int v49_IkChain = 16;
	int v53_IkChain = 32;
	int v49_Texture = 64;
	int v53_Texture = 44;
};

struct vector48_t //Not correct. -Liberty Edit: Correct. I think. -Liberty
{
	int16_t x;
	int16_t y;
	int16_t z;
};

struct Quaternion64
{
	int64_t x : 21;
	int64_t y : 21;
	int64_t z : 21;
	int64_t wneg : 1;
};

struct Quat48
{
	uint16_t x : 16;
	uint16_t y : 16;
	uint16_t z : 15;
	uint16_t wneg : 1;
};

struct Vector2
{
	float x;
	float y;
};

struct Vector3Short //What I like to use. -Liberty
{
	short x, y, z;

	short& operator[](int index) {
		switch (index)
		{
			case 0:
			{
				return x;
			}
			case 1:
			{
				return y;
			}
			case 2:
			{
				return z;
			}
			default:
			{
				return x;

			}
		}
	}
};

struct Vector3
{
	float x, y, z;
};

struct Vector4
{
	float x;
	float y;
	float z;
	float w;
};

struct QuaternionShort //What I like to use. -Liberty
{
	short one, i, j, k;
};

struct Quaternion
{
	float one;
	float i;
	float j;
	float k;
};

struct RadianEuler
{
	// for when you want radians in float.
	float x;
	float y;
	float z;
};

struct matrix3x4_t
{
	// unsure if that's how it actually works

	// row 1, x
	float c0r0; // x
	float c1r0; // x
	float c2r0; // x
	float c3r0; // x

	// row 2, y
	float c0r1; // y
	float c1r1; // y
	float c2r1; // y
	float c3r1; // y

	// row 3, z
	float c0r2; // z
	float c1r2; // z
	float c2r2; // z
	float c3r2; // z
};

struct seqstringbytesadded
{
	int szname;
	int activity;
	std::vector<int> activityevent;
	std::vector<int> activitymodifier;
};

struct stringtablebytesadded
{
	int stringtablesize;

	int mdlname;
	int surfaceprop;
	int unk;
	std::vector<int> bones;
	std::vector<int> attachments;
	std::vector<int> hitboxsets;
	std::vector<int> hitboxes;
	std::vector<int> anims;
	std::vector<seqstringbytesadded> seqs;
	std::vector<int> nodes;
	std::vector<int> bodyparts;
	std::vector<int> poseparams;
	std::vector<int> ikchains;
	std::vector<int> includemodel;
	int				 animblockname;
	std::vector<int> textures;
	std::vector<int> cdmaterials;
};

#pragma region ENUMS_AND_FLAGS

struct mdlflags_t
{
	// header flags
	
	// This flag is set if no hitbox information was specified
	#define STUDIOHDR_FLAGS_AUTOGENERATED_HITBOX	0x1
	
	// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
	// models when we change materials.
	#define STUDIOHDR_FLAGS_USES_ENV_CUBEMAP		0x2
	
	// Use this when there are translucent parts to the model but we're not going to sort it 
	#define STUDIOHDR_FLAGS_FORCE_OPAQUE			0x4
	
	// Use this when we want to render the opaque parts during the opaque pass
	// and the translucent parts during the translucent pass
	#define STUDIOHDR_FLAGS_TRANSLUCENT_TWOPASS		0x8
	
	// This is set any time the .qc files has $staticprop in it
	// Means there's no bones and no transforms
	#define STUDIOHDR_FLAGS_STATIC_PROP				0x10
	
	// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
	// models when we change materials.
	#define STUDIOHDR_FLAGS_USES_FB_TEXTURE		    0x20
	
	// This flag is set by studiomdl.exe if a separate "$shadowlod" entry was present
	//  for the .mdl (the shadow lod is the last entry in the lod list if present)
	#define STUDIOHDR_FLAGS_HASSHADOWLOD			0x40
	
	// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
	// models when we change materials.
	#define STUDIOHDR_FLAGS_USES_BUMPMAPPING		0x80
	
	// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
	// instead of overriding them with the default one (necessary for translucent shadows)
	#define STUDIOHDR_FLAGS_USE_SHADOWLOD_MATERIALS	0x100
	
	// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
	// instead of overriding them with the default one (necessary for translucent shadows)
	#define STUDIOHDR_FLAGS_OBSOLETE				0x200
	
	#define STUDIOHDR_FLAGS_UNUSED					0x400
	
	// NOTE:  This flag is set at mdl build time
	#define STUDIOHDR_FLAGS_NO_FORCED_FADE			0x800
	
	// NOTE:  The npc will lengthen the viseme check to always include two phonemes
	#define STUDIOHDR_FLAGS_FORCE_PHONEME_CROSSFADE	0x1000
	
	// This flag is set when the .qc has $constantdirectionallight in it
	// If set, we use constantdirectionallightdot to calculate light intensity
	// rather than the normal directional dot product
	// only valid if STUDIOHDR_FLAGS_STATIC_PROP is also set
	#define STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT 0x2000
	
	// Flag to mark delta flexes as already converted from disk format to memory format
	#define STUDIOHDR_FLAGS_FLEXES_CONVERTED		0x4000
	
	// Indicates the studiomdl was built in preview mode
	#define STUDIOHDR_FLAGS_BUILT_IN_PREVIEW_MODE	0x8000
	
	// Ambient boost (runtime flag)
	#define STUDIOHDR_FLAGS_AMBIENT_BOOST			0x10000
	
	// Don't cast shadows from this model (useful on first-person models)
	#define STUDIOHDR_FLAGS_DO_NOT_CAST_SHADOWS		0x20000
	
	// alpha textures should cast shadows in vrad on this model (ONLY prop_static!)
	#define STUDIOHDR_FLAGS_CAST_TEXTURE_SHADOWS	0x40000
	
	// Model has a quad-only Catmull-Clark SubD cage
	#define STUDIOHDR_FLAGS_SUBDIVISION_SURFACE		0x80000
	
	// flagged on load to indicate no animation events on this model
	#define STUDIOHDR_FLAGS_NO_ANIM_EVENTS			0x100000
	
	// If flag is set then studiohdr_t.flVertAnimFixedPointScale contains the
	// scale value for fixed point vert anim data, if not set then the
	// scale value is the default of 1.0 / 4096.0.  Regardless use
	// studiohdr_t::VertAnimFixedPointScale() to always retrieve the scale value
	#define STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE	0x200000
	
	
	#define STUDIOHDR_FLAGS_RESPAWN_UNK                 0x800000
	// "unkindex is only shifted if 0x1000000 flag is set on the studiohdr" talking about unkindex in mstudiomodel struct
	// unkindex is now colorindex
	#define STUDIOHDR_FLAGS_USES_VERTEX_COLOR           0x1000000 // hehe
	#define STUDIOHDR_FLAGS_RESPAWN_UNK1                0x1000000 // maybe related to vvc
	
	#define STUDIOHDR_FLAGS_RESPAWN_UNK2                0x2000000 // might be related to 2nd uv layer?
};

struct bone_flags //Taken from Rika's templates. Would've used mine but it will be easier for people to read and understand to use these instead. - Liberty
{
	#define BONE_CALCULATE_MASK			0x1F
	#define BONE_PHYSICALLY_SIMULATED	0x01	// bone is physically simulated when physics are active
	#define BONE_PHYSICS_PROCEDURAL		0x02	// procedural when physics is active
	#define BONE_ALWAYS_PROCEDURAL		0x04	// bone is always procedurally animated
	#define BONE_SCREEN_ALIGN_SPHERE	0x08	// bone aligns to the screen, not constrained in motion.
	#define BONE_SCREEN_ALIGN_CYLINDER	0x10	// bone aligns to the screen, constrained by it's own axis.
	
	#define BONE_WORLD_ALIGN 0x20 // bone is rigidly aligned to the world (but can still translate)(added in CSGO)
	
	#define BONE_USED_BY_IKCHAIN 0x20 // bone is influenced by IK chains, added in V52 (Titanfall 1)
	
	#define BONE_USED_MASK				0x0007FF00
	#define BONE_USED_BY_ANYTHING		0x0007FF00
	#define BONE_USED_BY_HITBOX			0x00000100	// bone (or child) is used by a hit box
	#define BONE_USED_BY_ATTACHMENT		0x00000200	// bone (or child) is used by an attachment point
	#define BONE_USED_BY_VERTEX_MASK	0x0003FC00
	#define BONE_USED_BY_VERTEX_LOD0	0x00000400	// bone (or child) is used by the toplevel model via skinned vertex
	#define BONE_USED_BY_VERTEX_LOD1	0x00000800	
	#define BONE_USED_BY_VERTEX_LOD2	0x00001000  
	#define BONE_USED_BY_VERTEX_LOD3	0x00002000
	#define BONE_USED_BY_VERTEX_LOD4	0x00004000
	#define BONE_USED_BY_VERTEX_LOD5	0x00008000
	#define BONE_USED_BY_VERTEX_LOD6	0x00010000
	#define BONE_USED_BY_VERTEX_LOD7	0x00020000
	#define BONE_USED_BY_BONE_MERGE		0x00040000	// bone is available for bone merge to occur against it
	
	#define BONE_FLAG_UNK_53            0x00080000
	
		//#define BONE_USED_BY_VERTEX_AT_LOD(lod) ( BONE_USED_BY_VERTEX_LOD0 << (lod) )
		//#define BONE_USED_BY_ANYTHING_AT_LOD(lod) ( ( BONE_USED_BY_ANYTHING & ~BONE_USED_BY_VERTEX_MASK ) | BONE_USED_BY_VERTEX_AT_LOD(lod) )
	
	#define BONE_TYPE_MASK				0x00F00000
	#define BONE_FIXED_ALIGNMENT		0x00100000	// bone can't spin 360 degrees, all interpolation is normalized around a fixed orientation
	
	#define BONE_HAS_SAVEFRAME_POS		0x00200000	// Vector48
	// v48 -> v49 : BONE_HAS_SAVEFRAME_ROT -> BONE_HAS_SAVEFRAME_ROT64
	#define BONE_HAS_SAVEFRAME_ROT64	0x00400000	// Quaternion64
	#define BONE_HAS_SAVEFRAME_ROT32	0x00800000	// Quaternion32
	
	#define BONE_FLAG_UNK_52            0x01000000
};

enum contents_flags
{
	CONTENTS_EMPTY = 0x0, // nonsolid
	CONTENTS_SOLID = 0x1, // solid
	CONTENTS_GRATE = 0x8, // grate
	CONTENTS_MONSTER = 0x2000000, // monster
	CONTENTS_LADDER = 0x20000000 // ladder
};

enum boneprocflags
{
	STUDIO_PROC_AXISINTERP = 1,
	STUDIO_PROC_QUATINTERP = 2,
	STUDIO_PROC_AIMATBONE = 3,
	STUDIO_PROC_AIMATATTACH = 4,
	STUDIO_PROC_JIGGLE = 5,
	STUDIO_PROC_TWIST_MASTER = 6,
	STUDIO_PROC_TWIST_SLAVE = 7
};

#define JIGGLE_IS_FLEXIBLE				0x01
#define JIGGLE_IS_RIGID					0x02
#define JIGGLE_HAS_YAW_CONSTRAINT		0x04
#define JIGGLE_HAS_PITCH_CONSTRAINT		0x08
#define JIGGLE_HAS_ANGLE_CONSTRAINT		0x10
#define JIGGLE_HAS_LENGTH_CONSTRAINT	0x20
#define JIGGLE_HAS_BASE_SPRING			0x40

//struct jiggleboneflags_t
//{
//	int _JIGGLE_IS_FLEXIBLE = JIGGLE_IS_FLEXIBLE : 1;
//	int _JIGGLE_IS_RIGID = JIGGLE_IS_RIGID : 1;
//	int _JIGGLE_HAS_YAW_CONSTRAINT = JIGGLE_HAS_YAW_CONSTRAINT : 1;
//	int _JIGGLE_HAS_PITCH_CONSTRAINT = JIGGLE_HAS_PITCH_CONSTRAINT : 1;
//	int _JIGGLE_HAS_ANGLE_CONSTRAINT = JIGGLE_HAS_ANGLE_CONSTRAINT : 1;
//	int _JIGGLE_HAS_LENGTH_CONSTRAINT = JIGGLE_HAS_LENGTH_CONSTRAINT : 1;
//	int _JIGGLE_HAS_BASE_SPRING = JIGGLE_HAS_BASE_SPRING : 1;
//	int unused : 25;
//};

enum hboxgroup
{
	Generic = 0,
	Head = 1,
	Chest = 2,
	Stomach = 3,
	Left_Arm = 4,
	Right_Arm = 5,
	Left_Leg = 6,
	Right_Leg = 7,
	Neck = 8
};

#pragma region ANIMDESCFLAGS

// sequence and autolayer flags
#define STUDIO_LOOPING		0x0001		// ending frame should be the same as the starting frame
#define STUDIO_SNAP			0x0002		// do not interpolate between previous animation and this one
#define STUDIO_DELTA		0x0004		// this sequence "adds" to the base sequences, not slerp blends
#define STUDIO_AUTOPLAY		0x0008		// temporary flag that forces the sequence to always play
#define STUDIO_POST			0x0010		// 
#define STUDIO_ALLZEROS		0x0020		// this animation/sequence has no real animation data
#define STUDIO_FRAMEANIM	0x0040		// animation is encoded as by frame x bone instead of RLE bone x frame
#define STUDIO_CYCLEPOSE	0x0080		// cycle index is taken from a pose parameter index
#define STUDIO_REALTIME		0x0100		// cycle index is taken from a real-time clock, not the animations cycle index
#define STUDIO_LOCAL		0x0200		// sequence has a local context sequence
#define STUDIO_HIDDEN		0x0400		// don't show in default selection views
#define STUDIO_OVERRIDE		0x0800		// a forward declared sequence (empty)
#define STUDIO_ACTIVITY		0x1000		// Has been updated at runtime to activity index
#define STUDIO_EVENT		0x2000		// Has been updated at runtime to event index on server
#define STUDIO_WORLD		0x4000		// sequence blends in worldspace
#define STUDIO_NOFORCELOOP	0x8000		// do not force the animation loop
#define STUDIO_EVENT_CLIENT 0x10000		// Has been updated at runtime to event index on client

#define STUDIO_ANIMDESC_53_UNK 0x20000	// actually first in v52
#define STUDIO_ANIMDESC_52_UNK 0x40000


#define STUDIO_ANIMDESC_53_UNK1 0x80000 // cherry blossom v53, levi in v54
#define STUDIO_FRAMEMOVEMENT    0x40000 // framemovements are only read if this flag is present

#pragma region ANIMFLAGS
// v48/49/52 flags
// v52 might've added flags for scale
#define STUDIO_ANIM_RAWPOS	0x01 // Vector48
#define STUDIO_ANIM_RAWROT	0x02 // Quaternion48
#define STUDIO_ANIM_ANIMPOS	0x04 // mstudioanim_valueptr_t
#define STUDIO_ANIM_ANIMROT	0x08 // mstudioanim_valueptr_t
#define STUDIO_ANIM_DELTA	0x10
#define STUDIO_ANIM_RAWROT2	0x20 // Quaternion64

// v53 flags
#define STUDIO_ANIM_RAWPOS_53	0x02 // Vector48
#define STUDIO_ANIM_RAWROT_53	0x04 // Quaternion48
#define STUDIO_ANIM_RAWSCALE_53	0x08 // Vector48
#define STUDIO_ANIM_READBONE_53 0x10 // read bone data if any of the above are disabled
#define STUDIO_ANIM_DELTA_53	0x1;

// v48/49/52 flags || Frame Anims
#define STUDIO_FRAME_RAWPOS		0x01 // Vector48 in constants
#define STUDIO_FRAME_RAWROT		0x02 // Quaternion48 in constants
#define STUDIO_FRAME_ANIMPOS	0x04 // Vector48 in framedata
#define STUDIO_FRAME_ANIMROT	0x08 // Quaternion48 in framedata
#define STUDIO_FRAME_FULLANIMPOS	0x10 // Vector in framedata
#pragma endregion

#pragma endregion

enum ikruletype
{
	IK_SELF = 1,
	IK_WORLD = 2,
	IK_GROUND = 3,
	IK_RELEASE = 4,
	IK_ATTACHMENT = 5,
	IK_UNLATCH = 6
};
#pragma endregion

#pragma region V49
//struct studioMdl_t_v49
//{
//	studiohdr_t_v49	 mdlhdr;
//	studiohdr2_t_v49 mdlsubhdr;
//
//	mstudiobone_t_v49*						bones;
//	mstudiojigglebone_t_v49*				jigglebones;
//	mstudioboneflexdriver_t_v49*			boneflexdrivers;
//	mstudioattachment_t_v49*				attachments;
//	mstudiohitboxset_t_v49*					hitboxsets;
//	mstudiobbox_t_v49*						hitboxes;
//	mstudiobonenametable_t_v49				bonenametable;
//	mstudioanimdesc_t_v49*					animdescs;
//	mstudioanim_t_v49*						anims;
//	sectionindexesindex_t_v49*				sectionindexes;
//	mstudioanim_t_v49*						sections;
//	mstudioikrule_t_v49*					ikrules;
//	mstudiocompressedikerror_t_v49*			compressedikerrors;
//	mstudioikerror_t_v49*					ikerrors;
//	mstudioikrulezeroframe_t_v49*			ikrulezeroframe;
//	mstudioseqdescv49_t*					seqdescs;
//	blendgroup_t_v49*						blends;
//	posekey_t_v49*							posekeys;
//	mstudioevent_t_v49*						events;
//	mstudioautolayer_t_v49*					autolayers;
//	mstudioactivitymodifier_t_v49*			activitymodifiers;
//	seqweightlist_t_v49*					seqweightlist;
//	mstudionodename_t_v49*					nodenames;
//	mstudionodedata_v49*					nodes;
//	mstudiobodyparts_t_v49*					bodyparts;
//	mstudiomodel_t_v49*						models;
//	mstudiomesh_t_v49*						meshes;
//	mstudioikchain_t_v49*					ikchains;
//	mstudioiklink_t_v49*					iklinks;
//	mstudioposeparamdesc_t_v49*				poseparamdescs;
//	mstudioanimblock_t*						animBlocks;
//	mstudiomodelgroup_t_v49*				includedmodels;
//	mstudiotexturedir_t_v49*				cdtextures;
//	mstudiotexture_t_v49*					textures;
//	mstudioskingroup_t_v49*					skingroups;
//	mstudiokeyvalues_t_v49					keyvalues;
//	mstudiosrcbonetransform_t_v49*			srcbonetransforms;
//	mstudiolinearbone_t_v49					linearbone;
//	mstudiolinearbonedata_t_v49				linearbonedata;
//
//};



struct studiohdr_t_v49
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	char name[64]; // The internal name of the model, padding with null bytes.
					// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int	localseqindex;

	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;

	// raw textures
	int numtextures;
	int textureindex;

	/// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numflexdesc;
	int flexdescindex;

	int numflexcontrollers;
	int flexcontrollerindex;

	int numflexrules;
	int flexruleindex;

	int numikchains;
	int ikchainindex;

	int nummouths;
	int mouthindex;

	int numlocalposeparameters;
	int localposeparamindex;

	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;


	float mass;
	int contents;

	// external animations, models, etc.
	int numincludemodels;
	int includemodelindex;

	uint32_t virtualModel;

	int szanimblocknameindex;
	int numanimblocks;
	int animblockindex;
	uint32_t animblockModel;

	int bonetablebynameindex;

	// used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	uint32_t pVertexBase;
	uint32_t pIndexBase;

	// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;

	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	int unused4; // zero out if version < 47

	int numflexcontrollerui;
	int flexcontrolleruiindex;

	float flVertAnimFixedPointScale;
	int surfacepropLookup; // this index must be cached by the loader, not saved in the file
						   // unused in v48 but it isn't worth making another struct over that.

	int studiohdr2index;

	// NOTE: No room to add stuff? Up the .mdl file format version 
	// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
	// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
	int unused2;
};

struct studiohdr2_t_v49
{
	// NOTE: For forward compat, make sure any methods in this struct
	// are also available in studiohdr_t so no leaf code ever directly references
	// a studiohdr2_t structure
	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	float flMaxEyeDeflection; // default to cos(30) if not set

	int linearboneindex;

	int sznameindex;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;

	int reserved[56];
};

struct mstudiobone_t_v49
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Quaternion quat;
	RadianEuler rot;

	// compression scale
	Vector3 posscale;
	Vector3 rotscale;

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

	int flags;
	int proctype;
	int procindex;			// procedural rule
	int physicsbone;		// index into physically simulated bone

	int surfacepropidx;		// index into string tablefor property name

	int contents;			// See BSPFlags.h for the contents flags

	int surfacepropLookup;	// this index must be cached by the loader, not saved in the file

	int unused[7];			// remove as appropriate
};

struct mstudiojigglebone_t_v49
{
	int flags;

	// general params
	float length; // how far from bone base, along bone, is tip
	float tipMass;

	// flexible params
	float yawStiffness;
	float yawDamping;
	float pitchStiffness;
	float pitchDamping;
	float alongStiffness;
	float alongDamping;

	// angle constraint
	float angleLimit; // maximum deflection of tip in radians

	// yaw constraint
	float minYaw; // in radians
	float maxYaw; // in radians
	float yawFriction;
	float yawBounce;

	// pitch constraint
	float minPitch; // in radians
	float maxPitch; // in radians
	float pitchFriction;
	float pitchBounce;

	// base spring
	float baseMass;
	float baseStiffness;
	float baseDamping;
	float baseMinLeft;
	float baseMaxLeft;
	float baseLeftFriction;
	float baseMinUp;
	float baseMaxUp;
	float baseUpFriction;
	float baseMinForward;
	float baseMaxForward;
	float baseForwardFriction;
};

struct mstudioboneflexdriver_t_v49
{
	int m_nBoneIndex;			// Bone to drive flex controller
	int m_nControlCount;		// Number of flex controllers being driven
	int m_nControlIndex;		// Index into data where controllers are (relative to this)

	int unused[3];
};

struct mstudioattachment_t_v49
{
	int sznameindex;
	int flags;

	int localbone;		      // parent bone

	matrix3x4_t localmatrix; // attachment point

	int	unused[8];


	std::string szname;
};

struct mstudiobonenametable_t_v49
{
	byte bone;
	byte* bones;
};

struct mstudioikchain_t_v49
{
	int sznameindex;

	int linktype;
	int numlinks;
	int linkindex;

	std::string szname;
};

struct mstudioiklink_t_v49
{
	int bone;
	Vector3	kneeDir; // ideal bending direction (per link, if applicable), unknown in v53
	Vector3	unused0; // unused in v49
};

struct mstudioiklock_t_v49
{
	int chain;
	float flPosWeight;
	float flLocalQWeight;
	int flags;

	int unused[4];
};

struct mstudioposeparamdesc_t_v49
{
	int sznameindex;

	int flags; 
	float start;		// starting value
	float end;			// ending value
	float loop;			// looping range, 0 for no looping, 360 for rotations, etc.

	std::string szname;
};

struct mstudiosrcbonetransform_t_v49
{
	int sznameindex;

	matrix3x4_t	pretransform;
	matrix3x4_t	posttransform;

	std::string szname;
};

struct mstudiolinearbone_t_v49
{
	int numbones;

	int flagsindex;

	int	parentindex;

	int	posindex;

	int quatindex;

	int rotindex;

	int posetoboneindex;

	int	posscaleindex;

	int	rotscaleindex;

	int	qalignmentindex;

	int unused[6];
};

struct mstudiolinearbonedata_t_v49
{
	uint32_t	flags[255];
	uint32_t	parents[255];
	Vector3		bonePos[255];
	Quaternion	boneQuat[255];
	RadianEuler boneRot[255];
	matrix3x4_t poseToBone[255];
	Vector3		posScale[255];
	Vector3		rotScale[255];
	Quaternion  boneAlignment[255];
};

struct mstudiobbox_t_v49
{
	int bone;
	int group;				// intersection group

	Vector3 bbmin;					// bounding box
	Vector3 bbmax;

	int szhitboxnameindex;			// offset to the name of the hitbox.

	int unused[8];

	std::string szhitboxname;
};

struct mstudiohitboxset_t_v49
{
	int sznameindex;

	int numhitboxes;
	int hitboxindex;

	std::string szname;

	mstudiobbox_t_v49* hitboxes = nullptr;
};

struct mstudioanimdesc_t_v49
{
	int baseptr;

	int sznameindex;

	float fps;						// frames per second	
	int	flags;						// looping/non-looping flags

	int numframes;

	// piecewise movement
	int	nummovements;
	int movementindex;

	int ikrulezeroframeindex;

	int unused1[5];					// remove as appropriate (and zero if loading older versions)	

	int animblock;
	int animindex;					// non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex;				// non-zero when IK data is stored in the mdl
	int animblockikruleindex;		// non-zero when IK data is stored in animblock file

	int numlocalhierarchy;
	int localhierarchyindex;;

	int sectionindex;
	int sectionframes;				// number of frames used in each fast lookup section, zero if not used

	short zeroframespan;			// frames per span
	short zeroframecount;			// number of spans
	int zeroframeindex;

	float zeroframestalltime;		// saved during read stalls

	std::string szname;
};

struct sectionindexesindex_t_v49
{
	int anioffset;			// unconfirmed
	int sectionoffset;
};

// used for piecewise loading of animation data
struct mstudioanimblock_t
{
	int datastart;
	int dataend;
};

struct mstudioanim_valueptr_t_v49
{
	int ptrPos = 0;
	Vector3Short offset = {0,0,0};
};

struct mstudioanimdata_t_v49
{
	int dataSize;
	std::vector<byte> arry;
};

struct mstudiofiller_t_v49
{
	std::vector<byte> arry;
};

struct mstudioanimvalue_t
{
	struct
	{
		// unsigned because it is in some places
		unsigned char	valid; // number of valid frames, or how many frames of data this value has
		unsigned char	total; // total number of frames, aka "values"
	} num;
	std::vector<short> value; // actual value, value*posscale
};

struct mstudioanimvalues_t_v49
{
	std::vector<mstudioanimvalue_t> rot;
	std::vector<mstudioanimvalue_t> pos;
};

struct mstudioanimvaluedata_t_v49
{
	std::vector<mstudioanimvalue_t> animData;
};

struct mstudioanim_t_v49
{
	int strPos = 0;

	byte bone; // alien swarm/csgo says this is a signed int but that doesn't work well for our purposes.
	byte flags;		// weighing options

    int16_t nextoffset;

    //STUDIO_ANIM_ANIMROT
        mstudioanim_valueptr_t_v49 animrot = { 0,0,0 }; // pRotV

	//STUDIO_ANIM_ANIMPOS
	    mstudioanim_valueptr_t_v49 animpos = { 0,0,0 }; // pPosV

	//STUDIO_ANIM_RAWROT
	    QuaternionShort rawrot = { 0,0,0,0 }; // pQuat48

	//STUDIO_ANIM_RAWROT2
		QuaternionShort rawrot2 = { 0,0,0,0 }; // pQuat64

	//STUDIO_ANIM_RAWPOS
	    Vector3Short rawpos = { 0,0,0 }; // pPos

	mstudioanimdata_t_v49 animdata;
	mstudiofiller_t_v49 filler;

	mstudioanimvalues_t_v49 animvalues;
};

struct mstudio_frame_anim_t
{
//	inline byte* pBoneFlags(void) const { return (((byte*)this) + sizeof(struct mstudio_frame_anim_t)); };

	int				constantsoffset;
//	inline byte* pConstantData(void) const { return (((byte*)this) + constantsoffset); };

	int				frameoffset;
	int 			framelength;
//	inline byte* pFrameData(int iFrame) const { return (((byte*)this) + frameoffset + iFrame * framelength); };

	int				unused[3];
};

struct mstudioikrule_t_v49
{
	int index;

	int type;
	int chain;

	int	bone;

	int slot;	// iktarget slot.  Usually same as chain.
	float height;
	float radius;
	float floor;
	Vector3 pos;
	Quaternion q;

	int compressedikerrorindex;

	int unused2;

	int iStart;
	int ikerrorindex;

	float start;	// beginning of influence
	float peak;		// start of full influence
	float tail;		// end of full influence
	float end;		// end of all influence

	float unused3;	
	float contact;	// frame footstep makes ground concact
	float drop;		// how far down the foot should drop when reaching for IK
	float top;		// top of the foot box

	int unused6;
	int unused7;
	int unused8;

	int szattachmentindex;		// name of world attachment

	int unused[7];
};

struct mstudiocompressedikerror_t_v49
{
	float scale[6];
	int16_t index[6]; //offset
	std::vector<mstudioanimvalue_t> animvalues;
	mstudioanimdata_t_v49 animdata;
	mstudiofiller_t_v49 filler;
};

struct mstudioikerror_t_v49
{
	Vector3 pos;
	Quaternion q;
};

struct mstudioikrulezeroframe_t_v49
{
	int16_t		chain;
	int16_t		slot;
	int16_t		start;	// beginning of influence
	int16_t		peak;	// start of full influence
	int16_t		tail;	// end of full influence
	int16_t		end;	// end of all influence
};

struct blendgroup_t_v49
{
	std::vector<short> blends;
};

struct mstudioseqdescv49_t
{
	int baseptr;

	int	szlabelindex;

	int szactivitynameindex;

	int flags;					// looping/non-looping flags

	int activity;				// initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;

	Vector3 bbmin;				// per sequence bounding box
	Vector3 bbmax;

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1groupsize[1] in length
	int animindexindex;

	int movementindex;		// [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2];		// X, Y, Z, XR, YR, ZR
	float paramstart[2];	// local (0..1) starting value
	float paramend[2];		// local (0..1) ending value
	int paramparent;

	float fadeintime;		// ideal cross fate in time (0.2 default)
	float fadeouttime;		// ideal cross fade out time (0.2 default)

	int localentrynode;		// transition node at entry
	int localexitnode;		// transition node at exit
	int nodeflags;			// transition rules

	float entryphase;		// used to match entry gait
	float exitphase;		// used to match exit gait

	float lastframe;		// frame that should generation EndOfSequence

	int nextseq;			// auto advancing sequences
	int pose;				// index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int	keyvalueindex;
	int keyvaluesize;

	int cycleposeindex;		// index of pose parameter to use as cycle index

	int activitymodifierindex;
	int numactivitymodifiers;

	int unused[5];

	std::string szlabel;
	std::string szactivityname;
	std::string* szeventnames = nullptr;
	std::vector<std::string> szactivitymodifiernames;

	std::vector<int> actmods;
	std::vector<int> events;
	blendgroup_t_v49 blends;

};

struct posekey_t_v49
{
	std::vector<float> unk;
};

struct mstudioevent_t_v49
{
	float cycle;
	int	event;
	int type;
	char options[64];

	int szeventindex;
};

struct mstudioautolayer_t_v49
{
	short iSequence;
	short iPose;

	int   flags;
	float start;	// beginning of influence
	float peak;		// start of full influence
	float tail;		// end of full influence
	float end;		// end of all influence
};

//struct blendgroup_t_v49
//{
//	int16_t blends[8];
//};

struct mstudioactivitymodifier_t_v49
{
	int setnum;
	int sznameindex;
	std::string szname;
};

struct seqweightlist_t_v49
{
	std::vector<float> boneweight;
};

struct mstudioseqdescdata_t_v49
{
	posekey_t_v49 posekey = {}; //posekey[seqdesc.groupsize[0] + seqdesc.groupsize[1]
	std::vector<mstudioevent_t_v49> events; //seqdesc.numevents
	std::vector<mstudioautolayer_t_v49> autolayers; //seqdesc.numautolayers
	seqweightlist_t_v49 weightlist; //mdlhdr.numbones
	//iklocks						//seqdesc.numiklocks
	blendgroup_t_v49 blendgroup; //blendgroup[seqdesc.groupsize[0] * seqdesc.groupsize[1]]
	std::vector<mstudioactivitymodifier_t_v49> actmods; //seqdesc.numactivitymodifiers;

};

struct mstudioseqdesc_t_v49
{
	int baseptr;

	int	szlabelindex;

	int szactivitynameindex;

	int flags;					// looping/non-looping flags

	int activity;				// initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;

	Vector3 bbmin;				// per sequence bounding box
	Vector3 bbmax;

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1groupsize[1] in length
	int animindexindex;

	int movementindex;		// [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2];		// X, Y, Z, XR, YR, ZR
	float paramstart[2];	// local (0..1) starting value
	float paramend[2];		// local (0..1) ending value
	int paramparent;

	float fadeintime;		// ideal cross fate in time (0.2 default)
	float fadeouttime;		// ideal cross fade out time (0.2 default)

	int localentrynode;		// transition node at entry
	int localexitnode;		// transition node at exit
	int nodeflags;			// transition rules

	float entryphase;		// used to match entry gait
	float exitphase;		// used to match exit gait

	float lastframe;		// frame that should generation EndOfSequence

	int nextseq;			// auto advancing sequences
	int pose;				// index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int	keyvalueindex;
	int keyvaluesize;

	int cycleposeindex;		// index of pose parameter to use as cycle index

	int activitymodifierindex;
	int numactivitymodifiers;

	int unused[5];

	mstudioseqdescdata_t_v49 seqdata;
};

//struct blendgroup_t_v49
//{
//	int16_t blends[8];
//};
struct mstudiomodelgroup_t_v49
{
	int szlabelindex;	// textual name
	int sznameindex;	// file name

	std::string szname;
};

struct mstudiobodyparts_t_v49
{
	int sznameindex;
	int nummodels;
	int base;
	int modelindex;		// index into models array

	std::string szname;
};

struct mstudiomodel_t_v49
{
	char	name[64];

	int		type;

	float	boundingradius;

	int		nummeshes;
	int		meshindex;

	// cache purposes
	int		numvertices;			// number of unique vertices/normals/texcoords
	int		vertexindex;			// vertex Vector
	int		tangentsindex;			// tangents Vector

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)

	int		numattachments;
	int		attachmentindex;

	int		numeyeballs;
	int		eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

	// sections of this are removed as needed.
	int		unused[10]; // remove as appropriate
					// first two get used in v47
};

struct mstudio_meshvertexdata_t_v49
{
	int unk;

	int numLODVertexes[MAX_NUM_LODS];
};

struct mstudiomesh_t_v49
{
	int		material;

	int		modelindex;

	int		numvertices;	// number of unique vertices/normals/texcoords
	int		vertexoffset;	// vertex mstudiovertex_t

	// Access thin/fat mesh vertex data (only one will return a non-NULL result)

	int		numflexes; // vertex animation
	int		flexindex;

	// special codes for material operations
	int		materialtype;
	int		materialparam;

	// a unique ordinal for this mesh
	int		meshid;

	Vector3 center;

	mstudio_meshvertexdata_t_v49 vertexdata;

	int		unused[8]; // remove as appropriate
};

struct mstudioboneweight_t_v49
{
	float		weight[MAX_NUM_BONES_PER_VERT];
	char		bone[MAX_NUM_BONES_PER_VERT];
	byte	numbones;
};

struct mstudiovertex_t_v49
{
	mstudioboneweight_t_v49	m_BoneWeights;
	Vector3					m_vecPosition;
	Vector3					m_vecNormal;
	Vector2					m_vecTexCoord;
};

struct mstudiotexturedir_t_v49
{
	int sznameindex;// file name

	std::string szname;
};

struct mstudiotexture_t_v49
{
	int sznameindex;

	int flags;
	int used;
	int unused1;

	int unused[12];

	std::string szname;
};

struct mstudioskingroup_t_v49
{
	int16_t textureId[64];
};

struct mstudionodedata_v49
{
	std::vector<int16_t> unk;
};

struct mstudionodename_t_v49
{
	int sznameindex;
	std::string szname;
};

struct pertriheader_t_v49
{
	int		version; // unsure if this is an actual version or type
				 // set to '2' for static prop.

	// aabb sizes, same as hulls
	Vector3 bbmin;
	Vector3 bbmax;

	int		unused[8]; // hopefully, checks out with other mdl structs 
};

struct mstudiokeyvalues_t_v49
{
	std::vector<char> value;
};

struct mstudioseqstring_t_v49
{
	std::string szname;
	std::string activity;
	std::vector<std::string> activityevent;
	std::vector<std::string> activitymodifier;
};

struct mstudiostringtable_t_v49
{
	int stringtablesize;

	std::string mdlname;
	std::string surfaceprop;
	std::string* bones;
	std::string* attachments;
	std::vector<std::string> hitboxsets;
	std::vector<std::string> hitboxes;
	std::vector<std::string> anims;
	std::vector<mstudioseqstring_t_v49> seqs;
	std::vector<std::string> nodes;
	std::vector<std::string> bodyparts;
	std::vector<std::string> poseparams;
	std::vector<std::string> ikchains;
	std::vector<std::string> includemodel;
	std::vector<std::string> textures;
	std::vector<std::string> cdmaterials;
};
#pragma endregion

#pragma region V52
struct studiohdr_t_v52
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	char name[64]; // The internal name of the model, padding with null bytes.
					// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	// highest observed: 250
	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int	localseqindex;

	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;

	// raw textures
	int numtextures;
	int textureindex;

	/// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numflexdesc;
	int flexdescindex;

	int numflexcontrollers;
	int flexcontrollerindex;

	int numflexrules;
	int flexruleindex;

	int numikchains;
	int ikchainindex;

	int nummouths;
	int mouthindex;

	int numlocalposeparameters;
	int localposeparamindex;

	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;


	float mass;
	int contents;

	// external animations, models, etc.
	int numincludemodels;
	int includemodelindex;

	uint32_t virtualModel;

	int szanimblocknameindex;
	int numanimblocks;
	int animblockindex;
	uint32_t animblockModel;

	int bonetablebynameindex;

	// used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	uint32_t pVertexBase;
	uint32_t pIndexBase;

	// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;

	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadedistance;

	int numflexcontrollerui;
	int flexcontrolleruiindex;

	float flVertAnimFixedPointScale;
	int surfacepropLookup;	// this index must be cached by the loader, not saved in the file

	// NOTE: No room to add stuff? Up the .mdl file format version 
	// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
	// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
	int studiohdr2index;

	int mayaindex; // in v52 not every model has these strings, only four bytes when not present.
};

struct studiohdr2_t_v52
{
	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	float flMaxEyeDeflection; // default to cos(30) if not set

	int linearboneindex;

	int sznameindex;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;

	// for static props (and maybe others)
	// Precomputed Per-Triangle AABB data
	int aabbindex;
	int numaabbnodes;
	int numaabbleaves;
	int numaabbverts;

	// always "" or "Titan"
	int unkstringindex;

	int reserved[39];
};

struct mayabakery_t
{
	std::vector<char> bakery;
};

struct mstudiobone_t_v52
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos; // base bone position
	Quaternion quat;
	RadianEuler rot; // base bone rotation

	// compression scale
	Vector3 posscale; // scale muliplier for bone position in animations
	Vector3 rotscale; // scale muliplier for bone rotation in animations

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

	int flags;
	boneprocflags proctype;
	int procindex; // procedural rule offset
	int physicsbone; // index into physically simulated bone

	int surfacepropidx; // index into string tablefor property name

	int contents; // See BSPFlags.h for the contents flags

	int surfacepropLookup; // this index must be cached by the loader, not saved in the file

	Vector3 unkvector;
	Vector3 unkvector1;

	int unused[1]; // remove as appropriate
};

struct mstudioanimdesc_t_v52
{
	int baseptr;

	int sznameindex;

	float fps; // frames per second	
	int flags; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int	nummovements;
	int movementindex;

	int ikrulezeroframeindex;

	int compressedikerrorindex;

	int unused1[4]; // remove as appropriate (and zero if loading older versions)	

	int animblock;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl
	int animblockikruleindex; // non-zero when IK data is stored in animblock file

	int numlocalhierarchy;
	int localhierarchyindex;;

	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used

	short zeroframespan; // frames per span
	short zeroframecount; // number of spans
	int zeroframeindex;

	float zeroframestalltime; // saved during read stalls

	std::string szname;
};

struct mstudiocompressedikerror_t_v52
{
	float scale[4]; // first three values are the same as what posscale (if it was used) is, fourth is similar to unkvector1.
	int16_t offset[4];
};

struct mstudioseqdesc_t_v52
{
	int baseptr;

	int	szlabelindex;

	int szactivitynameindex;

	int flags;					// looping/non-looping flags

	int activity;				// initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;

	Vector3 bbmin;				// per sequence bounding box
	Vector3 bbmax;

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1groupsize[1] in length
	int animindexindex;

	int movementindex;		// [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2];		// X, Y, Z, XR, YR, ZR
	float paramstart[2];	// local (0..1) starting value
	float paramend[2];		// local (0..1) ending value
	int paramparent;

	float fadeintime;		// ideal cross fate in time (0.2 default)
	float fadeouttime;		// ideal cross fade out time (0.2 default)

	int localentrynode;		// transition node at entry
	int localexitnode;		// transition node at exit
	int nodeflags;			// transition rules

	float entryphase;		// used to match entry gait
	float exitphase;		// used to match exit gait

	float lastframe;		// frame that should generation EndOfSequence

	int nextseq;			// auto advancing sequences
	int pose;				// index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int	keyvalueindex;
	int keyvaluesize;

	int cycleposeindex;		// index of pose parameter to use as cycle index

	int activitymodifierindex;
	int numactivitymodifiers;

	int unk;

	int unk1;

	int unused[3];

	std::string szlabel;
	std::string szactivityname;
	std::vector<std::string> szeventnames;
	std::vector<std::string> szactivitymodifiernames;

	std::vector<int> actmods; 
	std::vector<int> events;
	blendgroup_t_v49 blends;

};

struct mstudiomodel_t_v52
{
	char name[64];

	int type;

	float boundingradius;

	int nummeshes;
	int meshindex;

	// cache purposes
	int numvertices; // number of unique vertices/normals/texcoords
	int vertexindex; // vertex Vector
					 // offset by vertexindex number of bytes into vvd verts
	int tangentsindex; // tangents Vector
					   // offset by tangentsindex number of bytes into vvd tangents

	int numattachments;
	int attachmentindex;

	// might be cut
	int numeyeballs;
	int eyeballindex;

	//mstudio_modelvertexdata_t vertexdata;

	int unk[4];

	int unkindex;
	int unkindex1;

	int unused[4];
};

struct pertriheader_t
{
	int version; // unsure if this is an actual version or type
				 // set to '2' for static prop.

	// aabb sizes, same as hulls
	Vector3 bbmin;
	Vector3 bbmax;

	int unused[8]; // hopefully, checks out with other mdl structs 
};

struct aabbnode
{
	short           unk[3];
	short           unk1[3];
	int             children[2];    // negative numbers are -(leafs + 1), not nodes
};

struct aabbcollmaskmap
{
	int16_t collmaskid[3];
	int16_t unk1; //Contents?
};

struct aabbleaf
{
	short           mins[3];              // for frustum culling
	short           maxs[3];

	int             unk; //A flag or something like that? Doesn't seem dynamic. 

	aabbcollmaskmap map[12];
};

struct aabbcollisionmask
{
	std::vector<QuaternionShort> unk;
};

struct mstudiostringtable_t_v52
{
	int stringtablesize;

	std::string mdlname;
	std::string surfaceprop;
	std::string unk;
	std::vector<std::string> bones;
	std::vector<std::string> attachments;
	std::vector<std::string> hitboxsets;
	std::vector<std::string> hitboxes;
	std::vector<std::string> anims;
	std::vector<mstudioseqstring_t_v49> seqs;
	std::vector<std::string> nodes;
	std::vector<std::string> bodyparts;
	std::vector<std::string> poseparams;
	std::vector<std::string> ikchains;
	std::vector<std::string> includemodel;
	std::string				 animblockname;
	std::vector<std::string> textures;
	std::vector<std::string> cdmaterials;
};

#pragma endregion

#pragma region V53
struct studiohdr_t_v53
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex;// ;// + this - 12)>; // This has been moved from studiohdr2 to the front of the main header.
	std::vector<char> name; // The internal name of the model, padding with null bytes.
					// Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.

	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center

	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;

	int flags;

	// highest observed: 250
	// max is definitely 256 because 8bit uint limit
	int numbones; // bones
	int boneindex;

	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;

	int numhitboxsets;
	int hitboxsetindex;

	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions

	int numlocalseq; // sequences
	int	localseqindex;

	int activitylistversion; // initialization flag - have the sequences been indexed?
	int eventsindexed;

	// mstudiotexture_t
	// short rpak path
	// raw textures
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;

	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;

	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;

	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numflexdesc;
	int flexdescindex;

	int numflexcontrollers;
	int flexcontrollerindex;

	int numflexrules;
	int flexruleindex;

	int numikchains;
	int ikchainindex;

	int numruimeshes;
	int ruimeshindex;

	int numlocalposeparameters;
	int localposeparamindex;

	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;

	float mass;
	int contents;

	// external animations, models, etc.
	int numincludemodels;
	int includemodelindex;

	uint32_t virtualModel;

	// animblock is either completely cut, this is because they no longer use .ani files.

	int bonetablebynameindex;

	// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;

	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadedistance; // set to -1 to never fade. set above 0 if you want it to fade out, distance is in feet.
						// player/titan models seem to inherit this value from the first model loaded in menus.
						// works oddly on entities, probably only meant for static props

	int numflexcontrollerui;
	int flexcontrolleruiindex;

	// used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	// might not be correct
	uint32_t pVertexBase; // float flVertAnimFixedPointScale;
	uint32_t pIndexBase; // int surfacepropLookup;

	// this is in all shipped models, probably part of their asset bakery. it should be 0x2CC.
	// doesn't actually need to be written pretty sure, only four bytes when not present.
	// this is not completely true as some models simply have nothing, such as animation models.
	int mayaindex;

	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;

	int linearboneindex;

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;

	// for static props (and maybe others)
	// Precomputed Per-Triangle AABB data
	int aabbindex;
	int numaabbnodes;
	int numaabbleaves;
	int numaabbverts;

	// always "" or "Titan"
	int unkstringindex;// ;//(startof(mdlHeader) + mdlHeader.unkstringindex)>;

	// ANIs are no longer used and this is reflected in many structs
	// Start of interal file data
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize; // VTX
	int vvdsize; // VVD / IDSV
	int vvcsize; // VVC / IDCV 
	int vphysize; // VPHY / IVPS

	// this data block is related to the vphy, if it's not present the data will not be written
	// definitely related to phy, apex phy has this merged into it
	int unkmemberindex1; // section between vphy and vtx.?
	int numunkmember1; // only seems to be used when phy has one solid

	int unk;

	int unkindex3; // goes to the same spot as vtx normally.

	int* unused1 = new int[60]; // god I hope

	mstudiofiller_t_v49 filler;

};

struct mstudiobone_t_v53
{
	int sznameindex;

	int parent; // parent bone
	int bonecontroller[6]; // bone controller index, -1 == none

	// default values
	Vector3 pos;
	Quaternion quat;
	RadianEuler rot;

	Vector3 unkvector; // scale, porter named this though so like yea.
					   // pretty sure this is related to the new data type in mstudioanim

	// compression scale
	Vector3 posscale;
	Vector3 rotscale;

	Vector3 unkvector1; // compression scale for scale

	matrix3x4_t poseToBone;
	Quaternion qAlignment;

	int flags;
	int proctype;
	int procindex; // procedural rule
	int physicsbone; // index into physically simulated bone

	int surfacepropidx;// index into string tablefor property name

	int contents; // See BSPFlags.h for the contents flags

	int surfacepropLookup; // this index must be cached by the loader, not saved in the file

	// these two are related, toggle gets set to '1' when id is not -1
	int16_t unkid; // id is for unk section after phy
	int16_t unktoggle;

	int unused[7]; // remove as appropriate

	std::string szname;
};

struct mstudiolinearbonedata_t_v53
{
	uint32_t	flags[255];
	uint32_t	parents[255];
	Vector3		bonePos[255];
	Quaternion	boneQuat[255];
	RadianEuler boneRot[255];
	matrix3x4_t poseToBone[255];
	Vector3		rotScale[255];
	Quaternion  boneAlignment[255];
};

struct mstudioikchain_t_v53
{
	int sznameindex;

	int linktype;
	int numlinks;
	int linkindex;

	float unk; // no clue what this does tbh, tweaking it does nothing
			   // default value: 0.707f

	int unused[3]; // these get cut in apex so I can't imagine this is used

	std::string szname;
};

struct mstudiobbox_t_v53
{
	int bone;
	int group; // intersection group

	Vector3 bbmin; // bounding box
	Vector3 bbmax;

	int szhitboxnameindex; // offset to the name of the hitbox.

	int critoverride; // overrides the group to be a crit, 0 or 1. might be group override since group 1 is head.
	int keyvalueindex; // indexes into a kv group if used, mostly for titans.

	int unused[6];

	std::string szname;

	std::string szkvname;
};

struct mstudiohitboxset_t_v53
{
	int sznameindex;

	int numhitboxes;
	int hitboxindex;

	std::string szname;

	std::vector<mstudiobbox_t_v53> hitboxes;
};

struct mstudioanimdesc_t_v53
{
	int baseptr;

	int sznameindex;

	float fps; // frames per second	
	int flags; // looping/non-looping flags

	int numframes;

	// piecewise movement
	int nummovements;
	int movementindex;

	int compressedikerrorindex;
	int animindex; // non-zero when anim data isn't in sections

	int numikrules;
	int ikruleindex; // non-zero when IK data is stored in the mdl

	int numlocalhierarchy;
	int localhierarchyindex;

	int sectionindex;
	int sectionframes; // number of frames used in each fast lookup section, zero if not used

	short zeroframespan; // frames per span
	short zeroframecount; // number of spans
	int zeroframeindex;
	float zeroframestalltime; // saved during read stalls

	// ikrulezeroframeindex might be in here
	int unused[5];

	std::string szname;
};

struct sectionindexes_t_v53
{
	int sectionoffsets;
};

struct mstudioanim_t_v53
{
	float posscale = 0; // does what posscale is used for

	byte bone; // unsigned byte, bone limit exceeds 128 so has to be. also means max bones is 255.
	byte flags;

	int16_t unk = 0; // normally null data


	QuaternionShort rawrot = { 0,0,0, 0 }; // pQuat64

	mstudioanim_valueptr_t_v49 animrot = {0,0,0}; // pRotV
	int16_t unused = 0; // pretty sure


	Vector3Short rawpos = { 0,0,0 }; // pPos
	mstudioanim_valueptr_t_v49 animpos = { 0,0,0 }; // pPosV

	Vector3Short rawscale = { 0,0,0 }; // new in v53
	mstudioanim_valueptr_t_v49 animscale = { 0,0,0 };

	int nextoffset;

	mstudioanimdata_t_v49 animdata;
	mstudiofiller_t_v49 filler;
};

struct mstudioikrule_t_v53
{
	int index;
	int type;
	int chain;
	int bone;

	int slot; // iktarget slot. Usually same as chain.
	float height;
	float radius;
	float floor;
	Vector3 pos;
	Quaternion q;

	int compressedikerrorindex;

	int iStart;
	int ikerrorindex;

	float start; // beginning of influence
	float peak; // start of full influence
	float tail; // end of full influence
	float end; // end of all influence

	float contact; // frame footstep makes ground concact
	float drop; // how far down the foot should drop when reaching for IK
	float top; // top of the foot box

	int szattachmentindex; // name of world attachment

	int unused[9];
};

struct mstudioseqdesc_t_v53
{
	int baseptr;

	int	szlabelindex;

	int szactivitynameindex;

	int flags; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;

	Vector3 bbmin; // per sequence bounding box
	Vector3 bbmax;

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait

	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

	int activitymodifierindex;
	int numactivitymodifiers;

	// likely two unks here because you're supposed to grow back to 8 ints and not 10

	int unused[10]; // some might be used or they might've just been reseting space like on bones.

	std::string szlabel;
	std::string szactivityname;
	std::vector<std::string> szeventnames;
	std::vector<std::string> szactivitymodifiernames;

	std::vector<int> actmods;
	blendgroup_t_v49 blends;

};

struct mstudioactivitymodifier_t_v53
{
	int sznameindex;

	int unk;

	std::string szname;
};

struct mstudiotexture_t_v53
{
	int sznameindex;

	int flags;
	int used;
	int unused1;

	int unused[7];

	std::string szname;
};

struct mstudioseqstring_t_v53
{
	std::vector<char> szname;
	std::vector<char> activity;
	std::vector<char> activityevent;
	std::vector<char> activitymodifier;
};

struct mstudiostringtable_t_v53
{
	std::vector<char> mdlname;
	std::vector<char> surfaceprop;
	std::vector<std::vector<char>> bones;
	std::vector<std::vector<char>> attachments;
	std::vector<std::vector<char>> anims;
	std::vector<mstudioseqstring_t_v53> seqs;
	std::vector<std::vector<char>> nodes;
	std::vector<std::vector<char>> bodyparts;
	std::vector<std::vector<char>> poseparams;
	std::vector<std::vector<char>> ikchains;
	std::vector<std::vector<char>> includemodel;
	std::vector<std::vector<char>> textures;
	std::vector<std::vector<char>> cdmaterials;
};

struct mstudiorruiheader_t
{
	byte	ruiunk[4]; // unsure, it doesn't line up
	int			ruimeshindex;
};

// vertex map for a quad
struct mstudioruivertmap_t
{
	// order of vertices for triangles:
	// 1st tri: 1-3-2
	// 2nd tri: 4-2-3

	// three vertex set for base triangle
	// 1-3
	// sometimes this is just for tris and only has three verts.
	int16_t vertstartid;
	int16_t vertendid;

	//fourth// vert for second triangle
	// 4
	int16_t vertextraid;
};

struct mstudioruivert_t
{
	int		parent; // relative to global mesh parent, assumed

	Vector3 vertexpos; // position of vertex relative to bone
};

struct mstudioruimesface_t
{
	// these values are for the two vertices that are not shared
	// for the other do as such:
	// vertex 2: take x from vextex 1 and y from vextex 4
	// vertex 2: take x from vextex 4 and y from vextex 1

	// normal smd uv, seems to calculate for other values
	Vector2 faceuvmin; // vertex 1
	Vector2 faceuvmax; // vertex 4

	// these// could likely be calculated by doing math with a height/width scale
	// scale// of the ui element
	Vector2 facescalemin; // vertex 1
	Vector2 facescalemax; // vertex 4
};

struct mstudioruimesh_t
{
	int											numparents; // apparently you can have meshes parented to more than one bone(?)    
	int											numvertices; // number of verts
	int											numfaces; // number of faces (quads)

	int											parentindex; // this gets padding out front of it to even off the struct

	int											vertexindex; // offset into smd style vertex data
	int											vertmapindex; // offsets into a vertex map for each quad
	int											facedataindex; // offset into uv section

	byte									unk[4]; // zero sometimes, others not. has to do with face clipping.

	char*										szruimeshname[255]; // have to subtract header to get actual size (padding included)

	int16_t										parent[255]; // parent(s) bone of mesh
	
	mstudioruivertmap_t							vertexmap[255]; // vertex map for each face  
	mstudioruivert_t							vertex[255];
	
	mstudioruimesface_t							facedata[255];

};
#pragma endregion


struct mstudioruimesh_t_json
{
	int											numparents; // apparently you can have meshes parented to more than one bone(?)    
	int											numvertices; // number of verts
	int											numfaces; // number of faces (quads)

	int											parentindex; // this gets padding out front of it to even off the struct

	int											vertexindex; // offset into smd style vertex data
	int											vertmapindex; // offsets into a vertex map for each quad
	int											facedataindex; // offset into uv section

	byte									unk[4]; // zero sometimes, others not. has to do with face clipping.

	std::string									szruimeshname; // have to subtract header to get actual size (padding included)

	std::vector <int16_t>						parent; // parent(s) bone of mesh

	std::vector <mstudioruivertmap_t>			vertexmap; // vertex map for each face  
	std::vector <mstudioruivert_t>				vertex;

	std::vector <mstudioruimesface_t>			facedata;
};

struct Vector {
	float x, y, z;
};

struct Face {
	float uvMin[2];
	float uvMax[2];
	float faceScaleMin[2];
	float faceScaleMax[2];
	Vector one, three, two, four;
	int numOfVerts;
	int trisCount;
};

struct ruiRecipe
{
	std::string name;
	int parent;
	std::vector <Face> faces;
};
#pragma region PHY
//VPHY
struct phyheader_t
{
	int size; // Size of this header section (generally 16), this is also version.
	int id; // Often zero, unknown purpose.
	int numsolids; // Number of solids in file
	int checksum; // checksum of source .mdl file (4-bytes)
};

struct compactsurfaceheader_t
{
	int size; // size of the content after this byte
	int id;
	int16_t version;

	int16_t modeltype;

	int surfacesize;

	Vector3 dragaxisareas;

	int axismaparea;
};

struct legacysurfaceheader_t
{
	Vector3 mass_center;
	Vector3 rotation_inertia;

	float upper_limit_radius;

	// big if true
	//int	max_deviation : 24;
	//int	byte_size : 8;
	int	max_deviation;
	int	byte_size;

	int	nodeindex;

	int pad[2];

	int id;
};

struct trianglefaceheader_t
{
	int vertexindex; // from this member to verts
	int parent; // parent bone, starting at 1
	int flags;
	int numfaces;
};

// add this since we can actually read bone names
struct trianglefaceheader_t_v53
{
	int vertexindex; // from this member to verts
	int parent; // parent bone, starting at 1
	int flags;
	int numfaces;
};

struct trianglevertmap_t
{
	byte faceindex;
	byte unkdata[3];

	int16_t vertid;
	byte unkdata1[2];

	int16_t vertid1;
	byte unkdata2[2];

	int16_t vertid2;
	byte unkdata3[2];
};

struct phyvertex_t
{
	Vector3 pos; // relative to bone
	float unk;
};

struct phynode_t
{
	int rightnodeindex;
	int convexindex;

	Vector3 center;
	float radius;

	int bboxsize; // volume?
};

struct physection_t
{
	compactsurfaceheader_t surfaceheader;
	legacysurfaceheader_t surfaceheader2;
	trianglefaceheader_t trihdr;
	std::vector<trianglevertmap_t> vertmaps;

	std::vector<phyvertex_t> vertices;

	phynode_t node;
};
#pragma endregion
//DO NOT TOUCH -Liberty
struct mstudioruimeshhdr_t_v54
{
	int16_t numparents; // apparently you can have meshes parented to more than one bone(?)
	int16_t numvertices; // number of verts
	int16_t numfaces; // number of faces (quads)

	int16_t unk; // num uvs? or this is num faces and current num faces is num uvs

	int parentindex; // this gets padding out front of it to even off the struct

	int vertexindex; // offset into smd style vertex data
	int fourthvertmapindex; // they now fully map the vertices for each quad
	int vertmapindex; // offsets into a vertex map for each quad
	int facedataindex; // offset into uv section

	std::string									szruimeshname; // have to subtract header to get actual size (padding included)

	std::vector <int16_t>						parent; // parent(s) bone of mesh

	std::vector <mstudioruivertmap_t>			vertexmap; // vertex map for each face
	std::vector <int16_t>						unk1;
	std::vector <mstudioruivert_t>				vertex;

	std::vector <mstudioruimesface_t>			facedata;
};


